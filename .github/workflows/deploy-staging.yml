name: Deploy to Staging

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Deploy to Staging Server
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secrets
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
          POSTGRES_PASSWORD: ${{ secrets.STAGING_POSTGRES_PASSWORD }}
        run: |
          # URL-encode password for DB_DSN
          ENCODED_PASSWORD=$(printf '%s' "$POSTGRES_PASSWORD" | jq -sRr @uri)

          # Create .env content locally
          cat > /tmp/staging.env << ENVFILE
          # Environment
          ENVIRONMENT=staging

          # PostgreSQL
          POSTGRES_DB=${{ secrets.STAGING_POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.STAGING_POSTGRES_USER }}
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          DB_DSN=postgres://${{ secrets.STAGING_POSTGRES_USER }}:${ENCODED_PASSWORD}@postgres:5432/${{ secrets.STAGING_POSTGRES_DB }}?sslmode=disable

          # MinIO
          MINIO_ROOT_USER=${{ secrets.STAGING_MINIO_ROOT_USER }}
          MINIO_ROOT_PASSWORD=${{ secrets.STAGING_MINIO_ROOT_PASSWORD }}
          MINIO_ENDPOINT=minio:9000
          MINIO_ACCESS_KEY=${{ secrets.STAGING_MINIO_ROOT_USER }}
          MINIO_SECRET_KEY=${{ secrets.STAGING_MINIO_ROOT_PASSWORD }}

          # Gateway
          GATEWAY_PORT=8080
          GIN_MODE=release
          API_HOST=${{ secrets.STAGING_DOMAIN }}
          ALLOWED_ORIGINS=${{ secrets.STAGING_ALLOWED_ORIGINS }}

          # JWT
          JWT_SECRET=${{ secrets.STAGING_JWT_SECRET }}

          # Admin Secret Key
          ADMIN_SECRET_KEY=${{ secrets.STAGING_ADMIN_SECRET_KEY }}

          # Microservices
          USER_SERVICE_PORT=8081
          USER_SERVICE_URL=http://user-service:8081

          EVENT_SERVICE_PORT=8082
          EVENT_SERVICE_URL=http://event-service:8082

          APPLICATION_SERVICE_PORT=8083
          APPLICATION_SERVICE_URL=http://application-service:8083

          # Domain and SSL
          DOMAIN=${{ secrets.STAGING_DOMAIN }}
          SSL_EMAIL=${{ secrets.STAGING_SSL_EMAIL }}
          ENVFILE

          # Copy .env file to server
          echo "Uploading .env file to server..."
          scp /tmp/staging.env ${STAGING_SSH_USER}@${STAGING_HOST}:~/sovmestno-back/.env

          # Cleanup
          rm /tmp/staging.env

      - name: Deploy to server
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
        run: |
          ssh ${STAGING_SSH_USER}@${STAGING_HOST} << 'ENDSSH'
            set -e

            echo "Checking if repository exists..."
            if [ ! -d ~/sovmestno-back ]; then
              echo "Repository not found. Cloning..."
              cd ~
              git clone https://github.com/${{ github.repository }}.git sovmestno-back
            fi

            echo "Navigating to project directory..."
            cd ~/sovmestno-back

            echo "Pulling latest changes..."
            git pull origin main

            echo "Stopping services..."
            docker compose -f docker-compose.staging.yml down

            echo "Building services..."
            docker compose -f docker-compose.staging.yml build 2>&1

            echo "Generating nginx configuration from template..."
            # Remove nginx config if it's a directory (Docker creates it if file doesn't exist)
            if [ -d "nginx/nginx.staging.conf" ]; then
              echo "Removing nginx config directory..."
              rm -rf nginx/nginx.staging.conf
            fi

            echo "Loading environment variables..."
            set -a
            source .env
            set +a
            echo "DOMAIN is: $DOMAIN"

            echo "Generating nginx config from template..."
            envsubst '${DOMAIN}' < nginx/nginx.staging.conf.template > nginx/nginx.staging.conf

            echo "Verifying nginx config was created..."
            if [ ! -f "nginx/nginx.staging.conf" ]; then
              echo "ERROR: nginx config was not created!"
              exit 1
            fi
            echo "Nginx config size: $(wc -c < nginx/nginx.staging.conf) bytes"

            echo "===== STARTING SERVICES ====="
            echo "About to run: docker compose -f docker-compose.staging.yml up -d"
            docker compose -f docker-compose.staging.yml up -d
            UP_EXIT_CODE=$?
            echo "===== DOCKER COMPOSE UP FINISHED ====="
            echo "Exit code: $UP_EXIT_CODE"

            if [ $UP_EXIT_CODE -ne 0 ]; then
              echo "ERROR: docker compose up failed with exit code $UP_EXIT_CODE"
              exit 1
            fi

            echo "Waiting for containers to be created..."
            sleep 5

            echo "Container status:"
            docker compose -f docker-compose.staging.yml ps -a

            echo "Checking if gateway container exists..."
            if ! docker ps -a --format '{{.Names}}' | grep -q '^gateway$'; then
              echo "ERROR: Gateway container was not created!"
              echo "Docker compose up log:"
              cat /tmp/docker-up.log
              exit 1
            fi

            echo "Cleaning up old images..."
            docker image prune -f

            echo "Deployment complete!"

            echo "Service status:"
            docker compose -f docker-compose.staging.yml ps
          ENDSSH

      - name: Verify deployment
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
        run: |
          echo "Waiting 30 seconds for services to start..."
          sleep 30

          echo "Checking if gateway container is running..."
          if ssh ${STAGING_SSH_USER}@${STAGING_HOST} "docker ps --format '{{.Names}}' | grep -q '^gateway$'"; then
            echo "✓ Gateway container is running"
          else
            echo "✗ Gateway container is not running"
            ssh ${STAGING_SSH_USER}@${STAGING_HOST} "docker ps -a | grep gateway || echo 'Gateway container not found'"
            exit 1
          fi

          echo "Checking gateway health endpoint..."
          if ssh ${STAGING_SSH_USER}@${STAGING_HOST} "timeout 10 docker exec gateway wget --no-verbose --tries=1 -O /dev/null http://localhost:8080/health"; then
            echo "✓ Gateway is healthy"
          else
            echo "✗ Gateway health check failed"
            echo "Gateway logs:"
            ssh ${STAGING_SSH_USER}@${STAGING_HOST} "docker logs gateway --tail=50"
            exit 1
          fi

          echo "✓ All health checks passed!"

      - name: Send notification on failure
        if: failure()
        run: |
          echo "Deployment to staging failed!"
          # Add notification logic here (Telegram, Slack, etc.)
