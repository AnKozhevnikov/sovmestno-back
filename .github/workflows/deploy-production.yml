name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "DEPLOY TO PRODUCTION" to confirm'
        required: true
        type: string

jobs:
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    steps:
      - name: Check confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "DEPLOY TO PRODUCTION" ]; then
            echo "Deployment cancelled: confirmation text does not match"
            exit 1
          fi
          echo "Deployment confirmed"

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: production
      url: https://sovmestno-site.ru

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secrets
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
        run: |
          # Create .env content locally
          cat > /tmp/production.env << 'ENVFILE'
          # Environment
          ENVIRONMENT=production

          # PostgreSQL
          POSTGRES_DB=${{ secrets.PROD_POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.PROD_POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.PROD_POSTGRES_PASSWORD }}
          DB_DSN=postgres://${{ secrets.PROD_POSTGRES_USER }}:${{ secrets.PROD_POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.PROD_POSTGRES_DB }}?sslmode=disable

          # MinIO
          MINIO_ROOT_USER=${{ secrets.PROD_MINIO_ROOT_USER }}
          MINIO_ROOT_PASSWORD=${{ secrets.PROD_MINIO_ROOT_PASSWORD }}
          MINIO_ENDPOINT=minio:9000
          MINIO_ACCESS_KEY=${{ secrets.PROD_MINIO_ROOT_USER }}
          MINIO_SECRET_KEY=${{ secrets.PROD_MINIO_ROOT_PASSWORD }}

          # Gateway
          GATEWAY_PORT=8080
          GIN_MODE=release
          ALLOWED_ORIGINS=${{ secrets.PROD_ALLOWED_ORIGINS }}

          # JWT
          JWT_SECRET=${{ secrets.PROD_JWT_SECRET }}

          # Admin Secret Key
          ADMIN_SECRET_KEY=${{ secrets.ADMIN_SECRET_KEY }}

          # Microservices
          USER_SERVICE_PORT=8081
          USER_SERVICE_URL=http://user-service:8081

          EVENT_SERVICE_PORT=8082
          EVENT_SERVICE_URL=http://event-service:8082

          APPLICATION_SERVICE_PORT=8083
          APPLICATION_SERVICE_URL=http://application-service:8083

          # Domain and SSL
          DOMAIN=${{ secrets.PROD_DOMAIN }}
          SSL_EMAIL=${{ secrets.PROD_SSL_EMAIL }}
          ENVFILE

          # Copy .env file to server
          echo "Uploading .env file to server..."
          scp /tmp/production.env ${PROD_SSH_USER}@${PROD_HOST}:~/sovmestno-back/.env

          # Cleanup
          rm /tmp/production.env

      - name: Create backup
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
        run: |
          ssh ${PROD_SSH_USER}@${PROD_HOST} << 'ENDSSH'
            set -e

            echo "Creating backup..."
            cd ~/sovmestno-back

            # Load environment variables
            export $(grep -v '^#' .env | xargs)

            # Backup database
            docker exec postgres pg_dump -U $POSTGRES_USER $POSTGRES_DB > backup_$(date +%Y%m%d_%H%M%S).sql

            echo "Backup created"
          ENDSSH

      - name: Deploy to production server
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
        run: |
          ssh ${PROD_SSH_USER}@${PROD_HOST} << 'ENDSSH'
            set -e

            echo "Checking if repository exists..."
            if [ ! -d ~/sovmestno-back ]; then
              echo "Repository not found. Cloning..."
              cd ~
              git clone https://github.com/${{ github.repository }}.git sovmestno-back
            fi

            echo "Navigating to project directory..."
            cd ~/sovmestno-back

            echo "Pulling latest changes..."
            git pull origin main

            echo "Stopping services gracefully..."
            docker compose -f docker-compose.production.yml down --timeout 30

            echo "Building services..."
            docker compose -f docker-compose.production.yml build --no-cache

            echo "Starting services..."
            docker compose -f docker-compose.production.yml up -d

            echo "Cleaning up old images..."
            docker image prune -f

            echo "Deployment complete!"

            echo "Service status:"
            docker compose -f docker-compose.production.yml ps
          ENDSSH

      - name: Verify deployment
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
        run: |
          echo "Waiting 30 seconds for services to start..."
          sleep 30

          ssh ${PROD_SSH_USER}@${PROD_HOST} << 'ENDSSH'
            echo "Checking health endpoints..."

            # Check gateway health
            if docker exec gateway wget --no-verbose --tries=1 -O /dev/null http://localhost:8080/health; then
              echo "Gateway is healthy"
            else
              echo "Gateway health check failed"
              exit 1
            fi

            # Check event-service health
            if docker exec event-service wget --no-verbose --tries=1 -O /dev/null http://localhost:8082/health; then
              echo "Event service is healthy"
            else
              echo "Event service health check failed"
              exit 1
            fi

            # Check application-service health
            if docker exec application-service wget --no-verbose --tries=1 -O /dev/null http://localhost:8083/health; then
              echo "Application service is healthy"
            else
              echo "Application service health check failed"
              exit 1
            fi

            # Check user-service health
            if docker exec user-service wget --no-verbose --tries=1 -O /dev/null http://localhost:8081/health; then
              echo "User service is healthy"
            else
              echo "User service health check failed"
              exit 1
            fi
          ENDSSH

      - name: Rollback on failure
        if: failure()
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
        run: |
          echo "Deployment failed! Rolling back..."
          ssh ${PROD_SSH_USER}@${PROD_HOST} << 'ENDSSH'
            cd ~/sovmestno-back
            git reset --hard HEAD^
            docker compose -f docker-compose.production.yml down
            docker compose -f docker-compose.production.yml up -d
          ENDSSH

      - name: Send notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "Production deployment successful!"
          else
            echo "Production deployment failed!"
          fi
          # Add notification logic here (Telegram, Slack, email, etc.)
